Object subclass: #Blocks	instanceVariableNames: 'initial letter previous current frozen'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Blocks commentStamp: 'JonathanLam 10/5/2017 12:36' prior: 0!Class: I represent the blocks of the Tetris gameResponsibility: I instantiate and hold a collection of various  block types.I manipulate each block through rotation, translation, etc.I hold 3 states for each block (initial, current, previous).Collaborators:I collaborate with the Game - the game handles all aspects of the Blocks class I collrborate with the Dice - dice dictates which block type is createdI collaborate with the Board - I do calculations based on the board cells.Instantiation Example:b := Blocks new.b createBlock: (anInteger  asString) orientation: (anInteger asString) Internal Representation and Key Implementation Points.    Instance Variables	current:		<Object>	frozen:		<Object>	initial:		<Object>	letter:		<Object>	previous:		<Object>!!Blocks methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 15:06'!findMin	"findMin returns the smallest y coordinate in initial"		^initial min y.! !!Blocks methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 15:07'!isFrozen	"isFrozen returns the instance variable frozen"		^frozen.! !!Blocks methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 15:06'!getBlock	"getBlock returns the current block"		^current.! !!Blocks methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 15:07'!getLetter	"getLetter returns the letter of current block"		^letter! !!Blocks methodsFor: 'saving' stamp: 'JonathanLam 10/4/2017 15:08'!revertState	"revertState sets current  to previous"		current := previous deepCopy.! !!Blocks methodsFor: 'saving' stamp: 'JonathanLam 10/4/2017 15:11'!saveState	"saveState clones the collection, current and saves it in previous"		previous := current deepCopy.! !!Blocks methodsFor: 'initialization' stamp: 'JonathanLam 10/4/2017 14:53'!createBlock: choice orientation: o	"createBlock: choice orientation:o - instantiates a tetris block object with an initial                orientation.	 choice = tetris piece type	 o = initial orientation (rotated state)"		initial := OrderedCollection new.	frozen := false. 	(choice = '1') ifTrue: [		initial add: 0@0; add: 0@(-1); add: 1@(-1); add: 1@0.		letter := $y].	(choice = '2') ifTrue: [ 		initial add: 0@0; add: 1@0; add: 0@(-1); add: -1@(-1).		letter := $r].	(choice = '3') ifTrue: [ 		initial add: 0@0; add: -1@0; add: 0@(-1); add: 1@(-1).		letter := $g].	(choice = '4') ifTrue: [		initial add: 0@0; add: 1@0; add: -1@0; add: -1@(-1).		letter := $b].	(choice = '5') ifTrue: [ 		initial add: 0@0; add: -1@0; add: 1@0; add: 1@(-1).		letter := $o].	(choice = '6') ifTrue: [ 		initial add: 0@0; add: -1@0; add: 1@0; add: 0@(-1).		letter := $p].	(choice = '7') ifTrue: [ 		initial add: 0@0; add: -1@0; add: 1@0; add: 2@0.		letter := $c].		current := initial deepCopy.	(o asInteger - 1) timesRepeat: [ 		self rotate: 'R' ].	! !!Blocks methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:53'!down:offset	"down: offset - increases the y value of each cell in the block by an offset"		current do:[:item | item setX: (item x) setY: (item y + offset)].! !!Blocks methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:49'!teleport	"teleport moves the block from initial to current position"		| pivot |	pivot := current at: 1.	current := initial deepCopy.		self down: (pivot y).	self translate: (pivot x).			! !!Blocks methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:51'!translate: offset	"translate: offset - shifts each item horizontally in current by an offset"	current do:[:item | item setX: (item x + offset) setY: (item y)].! !!Blocks methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:53'!setFrozen	"setFrozen sets the instance variable frozen to true"		frozen := true.! !!Blocks methodsFor: 'action' stamp: 'JonathanLam 10/6/2017 01:58'!rotate: direction	"rotate: direction - rotates all items in the OrderedCollection, initial, left or right.	 It then calls the method teleport to change the values in the collection, current."	| temp |		(letter = $y) ifTrue: [ 		^self].	initial do:[:item | 		temp := item.				(temp = (initial first)) ifFalse: [ 			(direction = 'L') ifTrue: [ 				temp := temp leftRotated.].			(direction = 'R') ifTrue: [ 				temp := temp rightRotated.].			].						item setX: temp x setY: temp y.		].		self teleport.! !Object subclass: #Board	instanceVariableNames: 'cols rows template emptyRow'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Board commentStamp: 'JonathanLam 10/5/2017 12:59' prior: 0!Class:I represent the Board of the Tetris gameResponsibility:I instantiate the board of the Tetris game.I clear any full or partially filled lines off the boardI send information to the receiver.Collaborators:I collaborate with the Game class. it adds items onto the board  and requests to remove lines from the board.Instantiation Example:b := Board new.b createBoard: (anArray of Integers asString) Internal Representation and Key Implementation Points.    Instance Variables	cols:		<Object>	emptyRow:		<Object>	rows:		<Object>	template:		<Object>!!Board methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 14:40'!getDimension	"getDimesion returns a point object containing the number of cols, rows in template"		^cols@rows.! !!Board methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 14:39'!getBoard	"getBoard - returns the tetris board (template)"		^template.! !!Board methodsFor: 'initialization' stamp: 'JonathanLam 10/4/2017 14:39'!createBoard: dimensions	"createBoard: dimensions - creates a blank tetris board of size: cols, rows from dimension"	| bottom |		cols := (dimensions at: 1) asInteger.	rows := (dimensions at: 2) asInteger.	template := OrderedCollection new.		bottom := '+', ('-' repeat: cols), '+'.	emptyRow := '|', (' ' repeat: cols), '|'.		1 to: rows do: [ :i |		template add: ('|', (' ' repeat: cols), '|').	].	template addLast: bottom.! !!Board methodsFor: 'action' stamp: 'JonathanLam 10/5/2017 23:37'!setBoard: aCollection	"Sets template to aCollection. For testing purposes only"		template := aCollection deepCopy.	! !!Board methodsFor: 'action' stamp: 'JonathanLam 10/6/2017 00:12'!clearLine: aFullLine	"clearLine: aFullLine - finds either completely filled lines 	 or lines containing only one empty cell (depends on the bool - aFullLine).		 Ex.:	 if (aFullLine) --> search for filled lines	 else --> search for lines with only one cell missing		 Removes all lines that fit such criteria. Note: if (aFullLine = False) removes only the last          occurence that meets the criteria."	| temp line |	temp := OrderedCollection new.		1 to: rows do: [ :i |		line := template at: i.				aFullLine ifTrue: [			(line includes: $ ) ifFalse: [ 				temp add: i. 				]			 ].				aFullLine ifFalse: [			((line occurrencesOf: $ ) = 1) ifTrue: [ 				temp removeAll.				temp add: i.  				 ]			 ].	].		temp do: [ :l |		template at: l put: emptyRow. ]	! !Object subclass: #Dice	instanceVariableNames: 'sequence i'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Dice commentStamp: 'JonathanLam 10/5/2017 13:02' prior: 0!Class: I represent the dice for the Tetris game.Responsibility: I dictate which piece or  orientation the next block will be.Collaborator:I collaborate with the Game class.When called, I roll the the dice (anArray of Integers) and return an element inside the given array.Instantiation Example:d := Dice new.d createDice: (anArray of Strings)Internal Representation and Key Implementation Points.    Instance Variables	i:		<Object>	j:		<Object>	piece:		<Object>	pos:		<Object>	sequence:		<Object>!!Dice methodsFor: 'initialization' stamp: 'JonathanLam 10/6/2017 06:06'!setRoll: anArray	"createDice: anArray - instantiates the instance variables: 	 sequence = dice roll array	 i = starting index value"		sequence := anArray.	i := 0.	! !!Dice methodsFor: 'accessing' stamp: 'JonathanLam 10/5/2017 21:31'!getSequence	"getSequence returns the dice sequence asArray"		^sequence.! !!Dice methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 14:37'!roll	"roll increments i and returns the item at sequence[i]"		i := i + 1.			(i > sequence size) ifTrue: [ 		i := 1		].			^(sequence at: i).	! !Object subclass: #Game	instanceVariableNames: 'board dice block hit bottom commands moveList powerups numPieces gameOver prevBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!Game commentStamp: 'JonathanLam 10/5/2017 13:09' prior: 0!Class:I repesent the Tetris game.Responsibilities:I  am responsible for instantiating all objects in other classes (i.e.: Blocks, Board, Dice)I am responsible for running the game and manipulating each block on the boardI am responsible for checking constraints (i.e.: bounds, collisions)I am responsible for reading and writing to and from ReadStreams/WriteStreams.Collaborators:Blocks  - I instantiate all block objects  and handle their movementsBoard - I instantiate the board and tells it when to clearLinesDice - I instantiate the dice and request for a roll when needed.Instantiation Example:g := Game new.g readFrom: (aString or ReadStream)) Internal Representation and Key Implementation Points.    Instance Variables	block:		<Object>	board:		<Object>	bottom:		<Object>	commands:		<Object>	dice:		<Object>	hit:		<Object>	moveList:		<Object>	powerups:		<Object>!!Game methodsFor: 'action' stamp: 'JonathanLam 10/5/2017 00:04'!moves: command	"moves: command - moves a tetris piece by the given command	 and checks to see if move is possible or block is frozen"		block saveState.	(command = 'l') ifTrue: [		block translate: -1].	(command = 'L') ifTrue: [		block rotate: 'L'].	(command = 'r') ifTrue: [		block translate: 1].		(command = 'R') ifTrue: [		block rotate: 'R'].	(command = '+') ifTrue: [		[block isFrozen] whileFalse: [ 			block down: 1.					self collisionDetection: true.			(hit = true) ifTrue: [ 				block revertState].			self checkBelow.		].	].	(command = '.') ifTrue: [		block down: 1.].		self collisionDetection: false.	(hit = true) ifTrue: [ 		block revertState].	self checkBelow.! !!Game methodsFor: 'action' stamp: 'JonathanLam 10/6/2017 03:35'!checkBelow	"checkBelow checks to see if there any non-empty cells under the current tetris piece.	 If there is something below, the block's instance variable is set to frozen.	 This block can no longer move."	| piece temp |		piece := block getBlock.	bottom := 0.			piece do:[:pt |		(pt y > bottom) ifTrue: [ 			bottom := pt y].		].			piece do:[:pt |		temp := ((board getBoard) at: (bottom + 2)) at: (pt x + 2).		(temp = $ ) | (temp = $x) ifFalse: [			block setFrozen].		].	! !!Game methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:54'!addToBoard	"addToBoard adds the tetris block onto the board"		(block getBlock) do:[:pt |		((board getBoard) at: (pt y + 1)) at: (pt x + 2) put: (block getLetter).		].				! !!Game methodsFor: 'action' stamp: 'JonathanLam 10/4/2017 23:54'!addPowerUps	"addPowerUps places the powerups onto the tetris board"		| col row numRows|		numRows := (board getDimension) y.		powerups do:[:pt |			col := (pt at: 1) asInteger + 1.		row := (pt at: 2) asInteger.		row := (numRows - row) + 1.				((board getBoard) at: row) at: col put: $x.		].	! !!Game methodsFor: 'action' stamp: 'JonathanLam 10/6/2017 02:38'!collisionDetection: fall	"collisionDetection: fall - checks to see if there any non-empty cells on the board where	 the current tetris piece will move onto after a move command is received."	| piece temp count cell|	count := 0.	hit := false.	piece := block getBlock.		piece do:[:pt |		(pt y = -1) ifTrue: [			hit := true.			^self.]		].		piece do:[:pt |		cell := (pt x + 2)@(pt y + 1).		temp := ((board getBoard) at: (cell y)) at: (cell x).		(temp = $x) ifTrue: [ 					count := count + 1			].				(temp = $ ) | (temp = $x) ifFalse: [			hit := true.				].		].		(fall) ifFalse: [		count timesRepeat: [ 			board clearLine: false.			].		]! !!Game methodsFor: 'action' stamp: 'JonathanLam 10/6/2017 04:01'!spawnBlock	"spawnBlock places the tetris piece in the middle top of the board"		| y offset |		y := ((board getDimension x) / 2) floor.	offset := block findMin abs.		block down: offset.	block translate: (y - 1).		self collisionDetection: false.	hit ifTrue: [ 		gameOver := true		].				! !!Game methodsFor: 'initialization' stamp: 'JonathanLam 10/6/2017 08:18'!createGame	"createGame instantiates instance variables and calls startGame to begin Tetris."	moveList := OrderedCollection new.	powerups := OrderedCollection new.	numPieces := 0.	gameOver := false.		commands do: [:line |		(line first = 'board') ifTrue: [ 			board := Board new.			board createBoard: (line removeFirst; asArray)].				(line first = 'powerup') ifTrue: [ 			powerups add: (line removeFirst; asArray).			self addPowerUps.			].				(line first = 'dice') ifTrue: [ 			dice := Dice new.			dice setRoll: (line removeFirst; asArray)].				(line first ='moves') ifTrue: [ 			line removeFirst.			moveList := moveList, line.			].		].	self startGame.! !!Game methodsFor: 'initialization' stamp: 'JonathanLam 10/6/2017 08:03'!setUpBlock	"setupBlock instantiates the block object and determines the type of tetris block and its inital rotation"	block := Blocks new.	block createBlock: (dice roll) orientation: (dice roll).	self spawnBlock.	numPieces := numPieces + 1.! !!Game methodsFor: 'initialization' stamp: 'JonathanLam 10/6/2017 08:25'!startGame	"startGame begins the Tetris game until all moves commands are consumed"		dice ifNotNil: [  		self setUpBlock.	].		moveList do:[:moves |		moves do:[:move |							(block isFrozen) ifFalse: [ 				 self moves: (move asString)				].						(block isFrozen) ifTrue: [				self addToBoard.			   board clearLine: true.								prevBlock := block deepCopy.				self setUpBlock.								gameOver ifTrue: [					numPieces := numPieces - 1. 					^self ].				 ].			].		].		block ifNotNil: [		(block isFrozen) ifFalse: [			self addToBoard ].		].! !!Game methodsFor: 'initialization' stamp: 'JonathanLam 10/6/2017 09:31'!startGameOld	"startGame begins the Tetris game until all moves commands are consumed"	moveList do:[:moves |		moves do:[:move |						(block isNil) ifTrue: [				block := Blocks new.				block createBlock: (dice roll) orientation: (dice roll).				self spawnBlock.								gameOver ifTrue: [ 					^self ].								numPieces := numPieces + 1.				].						(block isFrozen) ifFalse: [ 				 self moves: (move asString)				].						(block isFrozen) ifTrue: [				self addToBoard.				block := nil.				board clearLine: true.				 ].			].		].		block ifNotNil: [			(block isFrozen) ifFalse: [		self addToBoard ].	].! !!Game methodsFor: 'instance creation' stamp: 'JonathanLam 10/5/2017 00:06'!readFrom: s	"readFrom: s - accepts either a string or a ReadStream and converts input into an                      OrderedCollection"		| stream stream2 sub |		commands := OrderedCollection new.		(s isString) ifTrue: [ 		 	stream := s readStream.] 		ifFalse: [			stream := s			].			[stream atEnd] whileFalse: [		stream2 := (stream nextLine) readStream.			sub := OrderedCollection new.					[stream2 atEnd] whileFalse: [ 			sub add: (stream2 nextDelimited: Character space).			].		commands add: sub.		sub := OrderedCollection new.			].		self createGame.! !!Game methodsFor: 'printing' stamp: 'JonathanLam 10/5/2017 00:05'!printOn: aWriteStream	"printOn: aWriteStream - prints the tetris board onto a WriteStream"		| boardState first|		boardState := board getBoard.	first := true.		boardState do: [: r |		aWriteStream nextPutAll: r.				(first) ifTrue: [			aWriteStream nextPutAll: ' ', (numPieces asString), ' pieces'.			first := false.			].		aWriteStream cr].		aWriteStream flush.! !!Game methodsFor: 'accessing' stamp: 'JonathanLam 10/6/2017 04:05'!checkGameOver	"checkGameOver returns the instance variable gameOver"		^gameOver.! !!Game methodsFor: 'accessing' stamp: 'JonathanLam 10/4/2017 23:57'!getBoard	"getBoard returns the tetris board as an OrderedCollection"		^board getBoard.! !!Game methodsFor: 'accessing' stamp: 'JonathanLam 10/5/2017 14:17'!getBlock	"getBlock returns current tetris piece"		^block! !!Game methodsFor: 'accessing' stamp: 'JonathanLam 10/6/2017 08:14'!getPrevBlock	"getPrevBlock returns the previous block object"		^prevBlock.! !!Game methodsFor: 'accessing' stamp: 'JonathanLam 10/6/2017 02:47'!getNumPieces	"getNumPieces returns the number of pieces spawned onto the game board"		^numPieces.! !TestCase subclass: #TestBlocks	instanceVariableNames: 'b'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:27'!testTranslate	"Test to see if the block shifted right 1 cell"		| temp point1 point2 |		b := Blocks new.	b createBlock: '1' orientation: '1'.		temp := (b getBlock) deepCopy.		b translate: 1.		1 to: (temp size) do: [:i |		point1 := (b getBlock) at: i.		point2 := (temp at: i).		self assert: (point1 x) - (point2 x) equals: 1.		]! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 00:55'!testMin	"Test to see if method returns correct minimum y value in a collection of points"		b := Blocks new.	b createBlock: '1' orientation: '1'.		self assert: (b findMin) equals: -1. ! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 00:56'!testLetter	"Test to see if method returns the correct tetris piece"		b := Blocks new.	b createBlock: '7' orientation: '1'.		self assert: (b getLetter) equals: $c. ! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:35'!testRotateLeft	"Test to see if the block rotated left"	| cells temp |		b := Blocks new.	b createBlock: '6' orientation: '4'.	cells := b getBlock.		temp := OrderedCollection with: 0@0 with: (-1)@0 with: 0@1 with: 0@(-1).	cells do: [:pt |		self assert: (temp includes: pt)].								! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:27'!testDown	"Test to see if the block shifted down 1 cell"		| temp point1 point2 |		b := Blocks new.	b createBlock: '1' orientation: '1'.		temp := (b getBlock) deepCopy.		b down: 1.		1 to: (temp size) do: [:i |		point1 := (b getBlock) at: i.		point2 := (temp at: i).		self assert: (point1 y) - (point2 y) equals: 1.		]! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 00:57'!testFrozen	"Test to check if block is not frozen when first created"		b := Blocks new.	b createBlock: '7' orientation: '1'.		self assert: (b isFrozen) equals: false. ! !!TestBlocks methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:34'!testRotateRight	"Test to see if the block rotated right"	| cells temp |		b := Blocks new.	b createBlock: '6' orientation: '2'.	cells := b getBlock.		temp := OrderedCollection with: 0@0 with: 0@1 with: 1@0 with: 0@(-1).	cells do: [:pt |		self assert: (temp includes: pt)].								! !TestCase subclass: #TestBoard	instanceVariableNames: 'b'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 23:55'!testFullLineClearMultiple	"Test to check if any filled lines. if so, removes them from the board"		| anArray aBoard emptyBoard|		b := Board new.	anArray := #('4' '4').	aBoard := OrderedCollection new.	emptyBoard := OrderedCollection new.		aBoard add: '|    |'; add: '|cccc|'; add: '|    |'; add: '|cccc|'; add: '+----+'.	emptyBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|    |'; add: '+----+'. 		b createBoard: anArray.	b setBoard: aBoard.	b clearLine: true.		self assert: emptyBoard equals: (b getBoard).! !!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 21:38'!testDimensions	"Test to see if board dimensions are equal to the given parameters at instantiation"		| anArray |		anArray := #('2' '3').	b := Board new.	b createBoard: anArray.		self assert: (anArray first asInteger) equals: (b getDimension x).! !!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 23:55'!testPowerUpClear	"Test to check if any lines with only one cell empty. if so, removes last occurence from the board"		| anArray aBoard emptyBoard|		b := Board new.	anArray := #('4' '4').	aBoard := OrderedCollection new.	emptyBoard := OrderedCollection new.		aBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|c cc|'; add: '+----+'.	emptyBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|    |'; add: '+----+'. 		b createBoard: anArray.	b setBoard: aBoard.	b clearLine: false.		self assert: emptyBoard equals: (b getBoard).! !!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 21:43'!testCollection	"Test to see if boardCollection is created properly"		| anArray aBoard |		anArray := #('4' '4').		aBoard := OrderedCollection new.	aBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|    |'; add: '+----+'. 		b := Board new.	b createBoard: anArray.		self assert: aBoard equals: (b getBoard).! !!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 23:44'!testFullLineClear	"Test to check if any filled lines. if so, removes them from the board"		| anArray aBoard emptyBoard|		b := Board new.	anArray := #('4' '4').	aBoard := OrderedCollection new.	emptyBoard := OrderedCollection new.		aBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|cccc|'; add: '+----+'.	emptyBoard add: '|    |'; add: '|    |'; add: '|    |'; add: '|    |'; add: '+----+'. 		b createBoard: anArray.	b setBoard: aBoard.	b clearLine: true.		self assert: emptyBoard equals: (b getBoard).! !!TestBoard methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 23:55'!testPowerUpClearMultiple	"Test to check if any lines with only one cell empty. if so, removes last occurence from the board"		| anArray aBoard emptyBoard|		b := Board new.	anArray := #('4' '4').	aBoard := OrderedCollection new.	emptyBoard := OrderedCollection new.		aBoard add: '|    |'; add: '|    |'; add: '|c cc|'; add: '|c cc|'; add: '+----+'.	emptyBoard add: '|    |'; add: '|    |'; add: '|c cc|'; add: '|    |'; add: '+----+'. 		b createBoard: anArray.	b setBoard: aBoard.	b clearLine: false.		self assert: emptyBoard equals: (b getBoard).! !TestCase subclass: #TestDice	instanceVariableNames: 'd'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!TestDice methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 06:06'!testIfArrayExists	"Test to see if the Array exists and is the same in the object"		| anArray |		anArray := #(1 2 3 4).	d := Dice new.	d setRoll: anArray.		self assert: (d getSequence = anArray).! !!TestDice methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 06:05'!testOne	"Mason Dice Test1"		| dice |		self assert: dice equals: nil. 	dice := Dice new.	#((1 2 3 4) (7 2 9 3)) do: [: seq |		dice setRoll: seq.		2 timesRepeat: [			seq do: [: each |				self assert: (dice roll) equals: each	]]].! !!TestDice methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 06:06'!testRollifAtEnd	"Test to see if roll will iterate over the list from the beginning once it reaches the end"		| anArray item  |		anArray := #(1 2 3 4).	d := Dice new.	d setRoll: anArray.		4 timesRepeat: [ d roll ].		self assert: (d roll = 1).! !TestCase subclass: #TestGame	instanceVariableNames: 'g b'	classVariableNames: ''	poolDictionaries: ''	category: 'Tetris'!!TestGame commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:55'!testLineRotation 	"Test to check if line can be rotated if the first move command is rotate.	 If assertion passes - means line cannot rotate if spawned on first row"	g:=Game new.	g readFrom: 'board 5 5dice 7 1moves R'.	b := g getBoard.		self assert: (b first) equals: '|cccc |'.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 04:25'!testGameOverBoard	"Test to check if Game Over state is reached. If so, no other block can be spawned onto the board.     If this test passes, then there should exist a blank line at the top of the board. This is	 because one empty row is not succifient enough to spawn another block (i.e.: a square piece	 requires two empty rows)"		| aLine |		g:=Game new.	g readFrom: 'board 4 5dice 1 1moves +++'.	aLine := (g getBoard) first: 2.	self assert: (g checkGameOver) equals: true.	self assert: (aLine first) equals: '|    |'.	self assert: (aLine second) equals: '| yy |'.	self assert: (g getNumPieces) equals: 2.! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 03:46'!testClearLine2	"Test to check if multiple filled lines will be cleared once the current piece is frozen"	| aLine |		g := Game new.	g readFrom: 'board 6 10dice 7 1 7 1 1 1moves l+l+rr+'.	aLine := (g getBoard last: 3).		self assert: (aLine first) equals: '|      |'.	self assert: (aLine second) equals: '|      |'.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 14:25'!testSpawnEven	"Test to see if block spawns in the middle if given cols are even"	g:=Game new.	g readFrom: 'board 4 4dice 1 1moves lr'.	b := g getBoard.		self assert: (b first = '| yy |').		! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 01:57'!testSquareRotation 	"Test to check if square can be rotated.	 If assertion passes - move is consumed but square is not rotated."	g:=Game new.	g readFrom: 'board 4 5dice 1 1moves R'.	b := g getBoard.		self assert: (b first) equals: '| yy |'.	self assert: (b second) equals: '| yy |'.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 04:20'!testGameOverBool	"Test to see if the game has reached Game Over state - gameOver = true.	 This means that no block is able to be spawned at the middle of the board.	 There exists a block already there in the way."		g:=Game new.	g readFrom: 'board 4 5dice 1 1moves +++'.	self assert: (g checkGameOver) equals: true.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 21:34'!testLineSpawnCorrectly 	"Test to see if the line piece is placed properly (Ex. pivot is placed on 2nd row)"	g:=Game new.	g readFrom: 'board 5 5dice 7 2moves lr'.	b := g getBoard.		self assert: ((b occurrencesOf: '| c   |') = 4).	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/5/2017 14:25'!testSpawnOdd	"Test to see if block spawns in the middle if given cols are odd"		g:=Game new.	g readFrom: 'board 5 4dice 1 1moves lr'.	b := g getBoard.		self assert: (b first = '| yy  |').		! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 02:49'!testNumberOfSpawnedPieces	"Tests to check if number of spawned tetris pieces is correct"		g := Game new.	g readFrom: 'board 8 10powerup 2 9dice 1 2 7 2 2moves llmoves l l+..'.	self assert: (g getNumPieces) equals: 2.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 03:48'!testPowerupClearLine	"Test to check if ONLY the bottom most line with only one empty cell will be cleared when a powerup is triggered"	| aLine |		g := Game new.	g readFrom: 'board 5 10dice 7 1 7 1 1 1powerup 1 9.moves l+l+l'.	aLine := (g getBoard last: 3).		self assert: (aLine first)  equals: '|cccc |'.	self assert: (aLine second) equals: '|     |'.	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 02:45'!testA1Example	"Tests the given example to see if output is the same"		| output |	g := Game new.	g readFrom: 'board 8 10powerup 2 9dice 1 2 7 2 2moves llmoves l l+..'.	output := OrderedCollection new.	output add: '|        |'; add: '| x      |'; add: '|   c    |'; add: '|   c    |'; 	add: '|   c    |'; add: '|   c    |'; add: '|        |'; add: '|        |'; add: '|yy      |';	add: '|yy      |'; add: '+--------+'.		self assert: output equals: (g getBoard).	! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 08:14'!testIfFrozen	"Test to see if block becomes frozen once it reaches the bottom"		g:=Game new.	g readFrom: 'board 4 4dice 1 1moves ..'.	b := g getBlock.	self assert: (g getPrevBlock isFrozen).! !!TestGame methodsFor: 'tests' stamp: 'JonathanLam 10/6/2017 03:43'!testClearLine1	"Test to check if a filled line will be cleared once the current piece is frozen"	| aLine |		g := Game new.	g readFrom: 'board 5 10dice 7 1 7 2moves l+rrr+'.	aLine := (g getBoard last: 2) first.		self assert: aLine equals: '|     |'.	! !