/**
Assignment #1 - Cryptography. Jonathan Lam. 500792483 
*/

// Import Section
import java.io.File;
import java.io.PrintWriter;
import java.io.FileNotFoundException;
import java.util.Random;
import java.util.Scanner;

/**
The class Decryptor receives 3 command-line arguments:
  (1) key - a key of type String
  (2) input- an input file containing text to be decrypted (input.txt)
  (3) output - an output file generated by this class (output.txt)

  Purpose: To decrypt a file (input.txt) into another file (output.txt)
*/
public class Decrypter
{
    /**
    Decrypts input file with key into another output file (.txt)
    @param args: an array of type String containing: {key, input, output}
    @return writes decrypted text into designated output destination
    */
    public static void main(String[] args) throws FileNotFoundException
    {
        // Variable Initialization ------------------------------------
        String key = args[0];                          // Command-line argument(1) 
        int hash = key.hashCode();

        File input = new File(args[1]);                // Command-line argument(2) 
        Scanner scanner = new Scanner(input);
        PrintWriter output = new PrintWriter(args[2]); // Command-line argument(3) 

        // Function Body ----------------------------------------------

        String text = "";
        while (scanner.hasNextLine()) 
        {
            text += scanner.nextLine();
        }

        write(text, hash, output);
        output.close();     
    }

    /**
    write(text, hash, output) writes decrypted text line-by-line to target
                              output file
    @param : (1) text - encrypted text 
             (2) hash - corresponding hash value of provided key from 
                        command line 
             (3) output - target destination
    @return void
    */
    public static void write(String text, int hash, PrintWriter output)
    {
        // Variable Initialization - - - - - - - - - - - - - - - - - - 
        int len = text.length();
        int max_chars = 64;
        int runs = (len/max_chars);

        // Function Body - - - - - - - - - - - - - - - - - - - - - - - 
        for (int i = 0; i < runs; i++)
        {
            String reversed_t = transposition_r(hash, text.substring(0,max_chars));
            String decrypted = substitution_r(hash, reversed_t);

            if (i == (runs - 1)) // If loop is at the last iteration
            {
                output.print(decrypted); // We do not want an additional line to be written
            }
            else 
            {
                output.println(decrypted);
                text = text.substring(max_chars); // Truncate text by 64 char with each iteration
            }
        }
    }

    /**
    random(rand, min, max) generates a random integer
    @param: (1) rand - an object of class Random
            (2) min - the minimum value that this function may return
            (3) max - the maximum value that this function may return
    @return a random value of type Int
    */
    public static int random(Random rand, int min, int max)
    {
        return (rand.nextInt(max - min + 1) + min); 
    }

    /**
    int_pattern(hash) generates a pattern for column order to be used
        in the reverse transposition cipher (transposition_r)
    @param: (1) hash - corresponding hash value of provided key from 
                       command line
    @return an array of type Int (nums) - column order pattern
    */
    public static int[] int_pattern(int hash)
    {
        // Variable Initialization - - - - - 
        int[] nums = {0,1,2,3,4,5,6,7};
        int runs = 100;

        Random rand = new Random(hash);

        // Function Body - - - - - - - - - - 
        for (int i = 0; i < runs; i++) 
        {
            int n = random(rand, 0, 7); // Set a random index, n
            int m = random(rand, 0, 7); // Set a random index, m

            int temp = nums[n];         // Swapping elements of index n, m
            nums[n] = nums[m];
            nums[m] = temp;
        }
        return nums;
    }

    /**
    alpha_pattern(hash, alphabet) generates a substtution pattern from a string of   
                                  alphabets with space (27 characters)
    @param: (1) hash - corresponding hash value of provided key from 
                       command line
            (2) alphabet - an array of type char corresponding to the letters
                          of the alphabet and space
    @return void
    */
    public static void alpha_pattern(int hash, char[] alphabet)
    {
        // Variable Initialization - - - - - -- - - -- - - - - -
        int runs = 100;
        Random rand = new Random(hash);

        // Function Body - - - - - - - - - - - - - - - - - - - - 
        for (int i = 0; i < runs; i++) 
        {
            int n = random(rand, 0, 26); // Set a random index, n
            int m = random(rand, 0, 26); // Set a random index, m

            char temp = alphabet[n];     // Swapping elements of index n, m
            alphabet[n] = alphabet[m];
            alphabet[m] = temp;
        }
    }

    /** 
    substitution_r(hash, text) reverses the substitution cipher 
                               applied to text during encryption
    @param: (1) hash - corresponding hash value of provided key from 
                       command line
            (2) text - encrypted text (of type String)
    @return the decrypted text
    */
    public static String substitution_r(int hash, String text) 
    {
        // Variable Initialization - - - - - - - - - - - - - -
        int text_len = text.length();
        String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
        int alpha_len = alphabet.length();

        char[] alpha_c = alphabet.toCharArray(); // To convert String to type char
        char[] text_c = text.toCharArray();

        char[] pattern = alphabet.toCharArray(); 
        alpha_pattern(hash, pattern);           // Modify object (pattern)

        // Function Body - - - - - - - - - - - - - - - - - - -
        for (int n = 0; n < text_len; n++) 
        {
            for (int m = 0; m < alpha_len; m++)
            {
                if (text_c[n] == pattern[m])    
                {
                    text_c[n] = alpha_c[m];     
                    break;
                }
                
            }
        }
        String decrypted = String.valueOf(text_c);
        return decrypted;
    }

    /**
    transposition_r(hash, text) reverses the transposition cipher applied
                                to text during encryption
    @param (1) hash - corresponding hash value of provided key from 
                      command line
           (2) text - encrypted text (of type String)
    @return a new_string prior to the transposition step in encryption
        
    */
    public static String transposition_r(int hash, String text) 
    {
        // Variable Initialization - - - - - - - - - - - - - - 
        int size = 8;
        int pos = 0;

        String new_string = "";

        int[] arr = int_pattern(hash);
        String[] table = new String[size];
        
        // Function Body - - - - - - - - - - - - - - - - - - - 
        for (int i: arr)
        {
            table[i] = text.substring(pos,(pos + 8));
            pos += size;
        }

        for (int row = 0; row < size; row++)
        {
            for (int col = 0; col < size; col++)
            {
                new_string += table[col].charAt(row);
            }
        }    
        return new_string; 
    }
}

